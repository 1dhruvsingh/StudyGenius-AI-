"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/page",{

/***/ "(app-pages-browser)/./lib/payment-service.ts":
/*!********************************!*\
  !*** ./lib/payment-service.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addPaymentMethod: function() { return /* binding */ addPaymentMethod; },\n/* harmony export */   deletePaymentMethod: function() { return /* binding */ deletePaymentMethod; },\n/* harmony export */   getDefaultPaymentMethod: function() { return /* binding */ getDefaultPaymentMethod; },\n/* harmony export */   getUserPaymentMethods: function() { return /* binding */ getUserPaymentMethods; },\n/* harmony export */   getUserPlanName: function() { return /* binding */ getUserPlanName; },\n/* harmony export */   hasActiveSubscription: function() { return /* binding */ hasActiveSubscription; },\n/* harmony export */   processPayment: function() { return /* binding */ processPayment; },\n/* harmony export */   setDefaultPaymentMethod: function() { return /* binding */ setDefaultPaymentMethod; },\n/* harmony export */   updatePaymentMethod: function() { return /* binding */ updatePaymentMethod; },\n/* harmony export */   validateCardDetails: function() { return /* binding */ validateCardDetails; }\n/* harmony export */ });\n/* harmony import */ var _auth_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./auth-utils */ \"(app-pages-browser)/./lib/auth-utils.ts\");\n// This is a mock payment service for demonstration purposes\n\n/**\n * Process a payment and activate subscription\n * In a real app, this would integrate with a payment processor like Stripe\n */ async function processPayment(planType, billingCycle, amount, paymentDetails) {\n    try {\n        // In a real implementation, this would call the payment processor API\n        await new Promise((resolve)=>setTimeout(resolve, 1500));\n        // Mock successful payment\n        const transactionId = \"txn-\".concat(Math.random().toString(36).substring(2, 12));\n        // Update user with subscription information\n        const user = (0,_auth_utils__WEBPACK_IMPORTED_MODULE_0__.getUserSession)();\n        if (!user) {\n            return {\n                success: false,\n                error: \"User not found. Please log in before subscribing.\"\n            };\n        }\n        // Calculate subscription dates\n        const startDate = new Date();\n        const endDate = new Date();\n        if (billingCycle === \"monthly\") {\n            endDate.setMonth(endDate.getMonth() + 1);\n        } else {\n            endDate.setFullYear(endDate.getFullYear() + 1);\n        }\n        // Create subscription plan\n        const subscription = {\n            name: planType === \"premium\" ? \"premium\" : \"academic\",\n            billingCycle: billingCycle === \"monthly\" ? \"monthly\" : \"annual\",\n            price: amount,\n            startDate: startDate.toISOString(),\n            endDate: endDate.toISOString()\n        };\n        // Update user with subscription information\n        const updatedUser = {\n            ...user,\n            subscription: {\n                plan: subscription.name,\n                isActive: true\n            },\n            // Deactivate trial if user is subscribing\n            trialStatus: {\n                isActive: false,\n                startDate: undefined,\n                endDate: undefined\n            }\n        };\n        // Save updated user\n        (0,_auth_utils__WEBPACK_IMPORTED_MODULE_0__.storeUserSession)(updatedUser);\n        return {\n            success: true,\n            transactionId,\n            subscription\n        };\n    } catch (error) {\n        console.error(\"Payment processing error:\", error);\n        return {\n            success: false,\n            error: \"An error occurred while processing your payment. Please try again.\"\n        };\n    }\n}\n/**\n * Check if a user has an active subscription\n */ function hasActiveSubscription(user) {\n    var _user_subscription;\n    if (!user) return false;\n    return ((_user_subscription = user.subscription) === null || _user_subscription === void 0 ? void 0 : _user_subscription.isActive) || false;\n}\n/**\n * Get the name of the user's current plan\n */ function getUserPlanName(user) {\n    var _user_subscription;\n    if (!user) return \"Free\";\n    if (!((_user_subscription = user.subscription) === null || _user_subscription === void 0 ? void 0 : _user_subscription.isActive)) return \"Free\";\n    return user.subscription.plan.charAt(0).toUpperCase() + user.subscription.plan.slice(1);\n}\n// Mock storage for payment methods (in a real app, this would be stored in a database)\nconst userPaymentMethods = {};\n/**\n * Get all payment methods for a user\n */ function getUserPaymentMethods(userId) {\n    return userPaymentMethods[userId] || [];\n}\n/**\n * Add a new payment method for a user\n */ function addPaymentMethod(userId, paymentMethod) {\n    // Generate a random ID for the payment method\n    const id = \"pm_\".concat(Math.random().toString(36).substr(2, 9));\n    // Create the new payment method\n    const newMethod = {\n        ...paymentMethod,\n        id\n    };\n    // Get the user's existing payment methods\n    const methods = getUserPaymentMethods(userId);\n    // If this is the first method or set as default, update all other methods\n    if (methods.length === 0 || newMethod.isDefault) {\n        // Set all existing methods to non-default\n        const updatedMethods = methods.map((method)=>({\n                ...method,\n                isDefault: false\n            }));\n        // Add the new method\n        userPaymentMethods[userId] = [\n            ...updatedMethods,\n            newMethod\n        ];\n    } else {\n        // Add the new method without changing defaults\n        userPaymentMethods[userId] = [\n            ...methods,\n            newMethod\n        ];\n    }\n    return newMethod;\n}\n/**\n * Update an existing payment method\n */ function updatePaymentMethod(userId, methodId, updates) {\n    // Get the user's existing payment methods\n    const methods = getUserPaymentMethods(userId);\n    // Find the method to update\n    const methodIndex = methods.findIndex((method)=>method.id === methodId);\n    if (methodIndex === -1) {\n        return null;\n    }\n    // Create the updated method\n    const updatedMethod = {\n        ...methods[methodIndex],\n        ...updates\n    };\n    // If setting as default, update all other methods\n    if (updates.isDefault) {\n        // Set all methods to non-default\n        methods.forEach((method)=>{\n            method.isDefault = false;\n        });\n    }\n    // Update the method\n    methods[methodIndex] = updatedMethod;\n    // Update the user's payment methods\n    userPaymentMethods[userId] = methods;\n    return updatedMethod;\n}\n/**\n * Delete a payment method\n */ function deletePaymentMethod(userId, methodId) {\n    // Get the user's existing payment methods\n    const methods = getUserPaymentMethods(userId);\n    // Find the method to delete\n    const methodIndex = methods.findIndex((method)=>method.id === methodId);\n    if (methodIndex === -1) {\n        return false;\n    }\n    // Check if it's the default method\n    const isDefault = methods[methodIndex].isDefault;\n    // Remove the method\n    methods.splice(methodIndex, 1);\n    // If we removed the default method and there are still methods left, set a new default\n    if (isDefault && methods.length > 0) {\n        methods[0].isDefault = true;\n    }\n    // Update the user's payment methods\n    userPaymentMethods[userId] = methods;\n    return true;\n}\n/**\n * Set a payment method as the default\n */ function setDefaultPaymentMethod(userId, methodId) {\n    // Get the user's existing payment methods\n    const methods = getUserPaymentMethods(userId);\n    // Find the method to set as default\n    const methodIndex = methods.findIndex((method)=>method.id === methodId);\n    if (methodIndex === -1) {\n        return false;\n    }\n    // Set all methods to non-default\n    methods.forEach((method)=>{\n        method.isDefault = false;\n    });\n    // Set the specified method as default\n    methods[methodIndex].isDefault = true;\n    // Update the user's payment methods\n    userPaymentMethods[userId] = methods;\n    return true;\n}\n/**\n * Get the default payment method for a user\n */ function getDefaultPaymentMethod(userId) {\n    // Get the user's existing payment methods\n    const methods = getUserPaymentMethods(userId);\n    // Find the default method\n    const defaultMethod = methods.find((method)=>method.isDefault);\n    return defaultMethod || null;\n}\n/**\n * Mock function to validate card details\n * In a real app, this would be handled by the payment processor\n */ function validateCardDetails(details) {\n    // Basic validation\n    if (!details.cardNumber.replace(/\\s/g, \"\").match(/^\\d{16}$/)) {\n        return {\n            valid: false,\n            error: \"Invalid card number\"\n        };\n    }\n    if (!details.cardName.trim()) {\n        return {\n            valid: false,\n            error: \"Cardholder name is required\"\n        };\n    }\n    if (!details.expiryMonth || !details.expiryYear) {\n        return {\n            valid: false,\n            error: \"Expiry date is required\"\n        };\n    }\n    if (!details.cvv.match(/^\\d{3}$/)) {\n        return {\n            valid: false,\n            error: \"Invalid CVV\"\n        };\n    }\n    // Check if card is expired\n    const now = new Date();\n    const expiryDate = new Date(parseInt(\"20\".concat(details.expiryYear)), parseInt(details.expiryMonth) - 1, 1);\n    if (expiryDate < now) {\n        return {\n            valid: false,\n            error: \"Card has expired\"\n        };\n    }\n    return {\n        valid: true\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9wYXltZW50LXNlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQSw0REFBNEQ7QUFJSTtBQW9DaEU7OztDQUdDLEdBQ00sZUFBZUUsZUFDcEJDLFFBQWdCLEVBQ2hCQyxZQUFvQixFQUNwQkMsTUFBYyxFQUNkQyxjQUE4QjtJQUU5QixJQUFJO1FBQ0Ysc0VBQXNFO1FBQ3RFLE1BQU0sSUFBSUMsUUFBUUMsQ0FBQUEsVUFBV0MsV0FBV0QsU0FBUztRQUVqRCwwQkFBMEI7UUFDMUIsTUFBTUUsZ0JBQWdCLE9BQW1ELE9BQTVDQyxLQUFLQyxNQUFNLEdBQUdDLFFBQVEsQ0FBQyxJQUFJQyxTQUFTLENBQUMsR0FBRztRQUVyRSw0Q0FBNEM7UUFDNUMsTUFBTUMsT0FBT2YsMkRBQWNBO1FBRTNCLElBQUksQ0FBQ2UsTUFBTTtZQUNULE9BQU87Z0JBQ0xDLFNBQVM7Z0JBQ1RDLE9BQU87WUFDVDtRQUNGO1FBRUEsK0JBQStCO1FBQy9CLE1BQU1DLFlBQVksSUFBSUM7UUFDdEIsTUFBTUMsVUFBVSxJQUFJRDtRQUVwQixJQUFJZixpQkFBaUIsV0FBVztZQUM5QmdCLFFBQVFDLFFBQVEsQ0FBQ0QsUUFBUUUsUUFBUSxLQUFLO1FBQ3hDLE9BQU87WUFDTEYsUUFBUUcsV0FBVyxDQUFDSCxRQUFRSSxXQUFXLEtBQUs7UUFDOUM7UUFFQSwyQkFBMkI7UUFDM0IsTUFBTUMsZUFBaUM7WUFDckNDLE1BQU12QixhQUFhLFlBQVksWUFBWTtZQUMzQ0MsY0FBY0EsaUJBQWlCLFlBQVksWUFBWTtZQUN2RHVCLE9BQU90QjtZQUNQYSxXQUFXQSxVQUFVVSxXQUFXO1lBQ2hDUixTQUFTQSxRQUFRUSxXQUFXO1FBQzlCO1FBRUEsNENBQTRDO1FBQzVDLE1BQU1DLGNBQW9CO1lBQ3hCLEdBQUdkLElBQUk7WUFDUFUsY0FBYztnQkFDWkssTUFBTUwsYUFBYUMsSUFBSTtnQkFDdkJLLFVBQVU7WUFDWjtZQUNBLDBDQUEwQztZ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c291cmNlc0NvbnRlbnQiOlsiLy8gVGhpcyBpcyBhIG1vY2sgcGF5bWVudCBzZXJ2aWNlIGZvciBkZW1vbnN0cmF0aW9uIHB1cnBvc2VzXG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgVXNlciB9IGZyb20gJy4vYXV0aC10eXBlcyc7XG5pbXBvcnQgeyBnZXRVc2VyU2Vzc2lvbiwgc3RvcmVVc2VyU2Vzc2lvbiB9IGZyb20gJy4vYXV0aC11dGlscyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGF5bWVudE1ldGhvZCB7XG4gIGlkOiBzdHJpbmc7XG4gIGNhcmRUeXBlOiAndmlzYScgfCAnbWFzdGVyY2FyZCcgfCAnYW1leCcgfCAnZGlzY292ZXInIHwgJ2dlbmVyaWMnO1xuICBsYXN0Rm91cjogc3RyaW5nO1xuICBleHBpcnlNb250aDogc3RyaW5nO1xuICBleHBpcnlZZWFyOiBzdHJpbmc7XG4gIGNhcmRob2xkZXJOYW1lOiBzdHJpbmc7XG4gIGlzRGVmYXVsdDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQYXltZW50RGV0YWlscyB7XG4gIGNhcmROdW1iZXI6IHN0cmluZztcbiAgY2FyZE5hbWU6IHN0cmluZztcbiAgZXhwaXJ5TW9udGg6IHN0cmluZztcbiAgZXhwaXJ5WWVhcjogc3RyaW5nO1xuICBjdnY6IHN0cmluZztcbiAgc2F2ZUNhcmQ/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN1YnNjcmlwdGlvblBsYW4ge1xuICBuYW1lOiAnZnJlZScgfCAncHJlbWl1bScgfCAnYWNhZGVtaWMnO1xuICBiaWxsaW5nQ3ljbGU6ICdtb250aGx5JyB8ICdhbm51YWwnO1xuICBwcmljZTogbnVtYmVyO1xuICBzdGFydERhdGU6IHN0cmluZztcbiAgZW5kRGF0ZTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBheW1lbnRSZXN1bHQge1xuICBzdWNjZXNzOiBib29sZWFuO1xuICBlcnJvcj86IHN0cmluZztcbiAgdHJhbnNhY3Rpb25JZD86IHN0cmluZztcbiAgc3Vic2NyaXB0aW9uPzogU3Vic2NyaXB0aW9uUGxhbjtcbn1cblxuLyoqXG4gKiBQcm9jZXNzIGEgcGF5bWVudCBhbmQgYWN0aXZhdGUgc3Vic2NyaXB0aW9uXG4gKiBJbiBhIHJlYWwgYXBwLCB0aGlzIHdvdWxkIGludGVncmF0ZSB3aXRoIGEgcGF5bWVudCBwcm9jZXNzb3IgbGlrZSBTdHJpcGVcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NQYXltZW50KFxuICBwbGFuVHlwZTogc3RyaW5nLCBcbiAgYmlsbGluZ0N5Y2xlOiBzdHJpbmcsXG4gIGFtb3VudDogbnVtYmVyLFxuICBwYXltZW50RGV0YWlsczogUGF5bWVudERldGFpbHNcbik6IFByb21pc2U8UGF5bWVudFJlc3VsdD4ge1xuICB0cnkge1xuICAgIC8vIEluIGEgcmVhbCBpbXBsZW1lbnRhdGlvbiwgdGhpcyB3b3VsZCBjYWxsIHRoZSBwYXltZW50IHByb2Nlc3NvciBBUElcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTUwMCkpO1xuICAgIFxuICAgIC8vIE1vY2sgc3VjY2Vzc2Z1bCBwYXltZW50XG4gICAgY29uc3QgdHJhbnNhY3Rpb25JZCA9IGB0eG4tJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgMTIpfWA7XG4gICAgXG4gICAgLy8gVXBkYXRlIHVzZXIgd2l0aCBzdWJzY3JpcHRpb24gaW5mb3JtYXRpb25cbiAgICBjb25zdCB1c2VyID0gZ2V0VXNlclNlc3Npb24oKTtcbiAgICBcbiAgICBpZiAoIXVzZXIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogJ1VzZXIgbm90IGZvdW5kLiBQbGVhc2UgbG9nIGluIGJlZm9yZSBzdWJzY3JpYmluZy4nXG4gICAgICB9O1xuICAgIH1cbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgc3Vic2NyaXB0aW9uIGRhdGVzXG4gICAgY29uc3Qgc3RhcnREYXRlID0gbmV3IERhdGUoKTtcbiAgICBjb25zdCBlbmREYXRlID0gbmV3IERhdGUoKTtcbiAgICBcbiAgICBpZiAoYmlsbGluZ0N5Y2xlID09PSAnbW9udGhseScpIHtcbiAgICAgIGVuZERhdGUuc2V0TW9udGgoZW5kRGF0ZS5nZXRNb250aCgpICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVuZERhdGUuc2V0RnVsbFllYXIoZW5kRGF0ZS5nZXRGdWxsWWVhcigpICsgMSk7XG4gICAgfVxuICAgIFxuICAgIC8vIENyZWF0ZSBzdWJzY3JpcHRpb24gcGxhblxuICAgIGNvbnN0IHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uUGxhbiA9IHtcbiAgICAgIG5hbWU6IHBsYW5UeXBlID09PSAncHJlbWl1bScgPyAncHJlbWl1bScgOiAnYWNhZGVtaWMnIGFzICdwcmVtaXVtJyB8ICdhY2FkZW1pYycsXG4gICAgICBiaWxsaW5nQ3ljbGU6IGJpbGxpbmdDeWNsZSA9PT0gJ21vbnRobHknID8gJ21vbnRobHknIDogJ2FubnVhbCcsXG4gICAgICBwcmljZTogYW1vdW50LFxuICAgICAgc3RhcnREYXRlOiBzdGFydERhdGUudG9JU09TdHJpbmcoKSxcbiAgICAgIGVuZERhdGU6IGVuZERhdGUudG9JU09TdHJpbmcoKVxuICAgIH07XG4gICAgXG4gICAgLy8gVXBkYXRlIHVzZXIgd2l0aCBzdWJzY3JpcHRpb24gaW5mb3JtYXRpb25cbiAgICBjb25zdCB1cGRhdGVkVXNlcjogVXNlciA9IHtcbiAgICAgIC4uLnVzZXIsXG4gICAgICBzdWJzY3JpcHRpb246IHtcbiAgICAgICAgcGxhbjogc3Vic2NyaXB0aW9uLm5hbWUsXG4gICAgICAgIGlzQWN0aXZlOiB0cnVlXG4gICAgICB9LFxuICAgICAgLy8gRGVhY3RpdmF0ZSB0cmlhbCBpZiB1c2VyIGlzIHN1YnNjcmliaW5nXG4gICAgICB0cmlhbFN0YXR1czoge1xuICAgICAgICBpc0FjdGl2ZTogZmFsc2UsXG4gICAgICAgIHN0YXJ0RGF0ZTogdW5kZWZpbmVkLFxuICAgICAgICBlbmREYXRlOiB1bmRlZmluZWRcbiAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIC8vIFNhdmUgdXBkYXRlZCB1c2VyXG4gICAgc3RvcmVVc2VyU2Vzc2lvbih1cGRhdGVkVXNlcik7XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICB0cmFuc2FjdGlvbklkLFxuICAgICAgc3Vic2NyaXB0aW9uXG4gICAgfTtcbiAgICBcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdQYXltZW50IHByb2Nlc3NpbmcgZXJyb3I6JywgZXJyb3IpO1xuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGVycm9yOiAnQW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgcHJvY2Vzc2luZyB5b3VyIHBheW1lbnQuIFBsZWFzZSB0cnkgYWdhaW4uJ1xuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHVzZXIgaGFzIGFuIGFjdGl2ZSBzdWJzY3JpcHRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc0FjdGl2ZVN1YnNjcmlwdGlvbih1c2VyPzogVXNlciB8IG51bGwpOiBib29sZWFuIHtcbiAgaWYgKCF1c2VyKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB1c2VyLnN1YnNjcmlwdGlvbj8uaXNBY3RpdmUgfHwgZmFsc2U7XG59XG5cbi8qKlxuICogR2V0IHRoZSBuYW1lIG9mIHRoZSB1c2VyJ3MgY3VycmVudCBwbGFuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRVc2VyUGxhbk5hbWUodXNlcj86IFVzZXIgfCBudWxsKTogc3RyaW5nIHtcbiAgaWYgKCF1c2VyKSByZXR1cm4gJ0ZyZWUnO1xuICBpZiAoIXVzZXIuc3Vic2NyaXB0aW9uPy5pc0FjdGl2ZSkgcmV0dXJuICdGcmVlJztcbiAgcmV0dXJuIHVzZXIuc3Vic2NyaXB0aW9uLnBsYW4uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB1c2VyLnN1YnNjcmlwdGlvbi5wbGFuLnNsaWNlKDEpO1xufVxuXG4vLyBNb2NrIHN0b3JhZ2UgZm9yIHBheW1lbnQgbWV0aG9kcyAoaW4gYSByZWFsIGFwcCwgdGhpcyB3b3VsZCBiZSBzdG9yZWQgaW4gYSBkYXRhYmFzZSlcbmNvbnN0IHVzZXJQYXltZW50TWV0aG9kczogUmVjb3JkPHN0cmluZywgUGF5bWVudE1ldGhvZFtdPiA9IHt9O1xuXG4vKipcbiAqIEdldCBhbGwgcGF5bWVudCBtZXRob2RzIGZvciBhIHVzZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFVzZXJQYXltZW50TWV0aG9kcyh1c2VySWQ6IHN0cmluZyk6IFBheW1lbnRNZXRob2RbXSB7XG4gIHJldHVybiB1c2VyUGF5bWVudE1ldGhvZHNbdXNlcklkXSB8fCBbXTtcbn1cblxuLyoqXG4gKiBBZGQgYSBuZXcgcGF5bWVudCBtZXRob2QgZm9yIGEgdXNlclxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkUGF5bWVudE1ldGhvZCh1c2VySWQ6IHN0cmluZywgcGF5bWVudE1ldGhvZDogT21pdDxQYXltZW50TWV0aG9kLCAnaWQnPik6IFBheW1lbnRNZXRob2Qge1xuICAvLyBHZW5lcmF0ZSBhIHJhbmRvbSBJRCBmb3IgdGhlIHBheW1lbnQgbWV0aG9kXG4gIGNvbnN0IGlkID0gYHBtXyR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpfWA7XG4gIFxuICAvLyBDcmVhdGUgdGhlIG5ldyBwYXltZW50IG1ldGhvZFxuICBjb25zdCBuZXdNZXRob2Q6IFBheW1lbnRNZXRob2QgPSB7XG4gICAgLi4ucGF5bWVudE1ldGhvZCxcbiAgICBpZFxuICB9O1xuICBcbiAgLy8gR2V0IHRoZSB1c2VyJ3MgZXhpc3RpbmcgcGF5bWVudCBtZXRob2RzXG4gIGNvbnN0IG1ldGhvZHMgPSBnZXRVc2VyUGF5bWVudE1ldGhvZHModXNlcklkKTtcbiAgXG4gIC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IG1ldGhvZCBvciBzZXQgYXMgZGVmYXVsdCwgdXBkYXRlIGFsbCBvdGhlciBtZXRob2RzXG4gIGlmIChtZXRob2RzLmxlbmd0aCA9PT0gMCB8fCBuZXdNZXRob2QuaXNEZWZhdWx0KSB7XG4gICAgLy8gU2V0IGFsbCBleGlzdGluZyBtZXRob2RzIHRvIG5vbi1kZWZhdWx0XG4gICAgY29uc3QgdXBkYXRlZE1ldGhvZHMgPSBtZXRob2RzLm1hcChtZXRob2QgPT4gKHtcbiAgICAgIC4uLm1ldGhvZCxcbiAgICAgIGlzRGVmYXVsdDogZmFsc2VcbiAgICB9KSk7XG4gICAgXG4gICAgLy8gQWRkIHRoZSBuZXcgbWV0aG9kXG4gICAgdXNlclBheW1lbnRNZXRob2RzW3VzZXJJZF0gPSBbLi4udXBkYXRlZE1ldGhvZHMsIG5ld01ldGhvZF07XG4gIH0gZWxzZSB7XG4gICAgLy8gQWRkIHRoZSBuZXcgbWV0aG9kIHdpdGhvdXQgY2hhbmdpbmcgZGVmYXVsdHNcbiAgICB1c2VyUGF5bWVudE1ldGhvZHNbdXNlcklkXSA9IFsuLi5tZXRob2RzLCBuZXdNZXRob2RdO1xuICB9XG4gIFxuICByZXR1cm4gbmV3TWV0aG9kO1xufVxuXG4vKipcbiAqIFVwZGF0ZSBhbiBleGlzdGluZyBwYXltZW50IG1ldGhvZFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlUGF5bWVudE1ldGhvZCh1c2VySWQ6IHN0cmluZywgbWV0aG9kSWQ6IHN0cmluZywgdXBkYXRlczogUGFydGlhbDxPbWl0PFBheW1lbnRNZXRob2QsICdpZCc+Pik6IFBheW1lbnRNZXRob2QgfCBudWxsIHtcbiAgLy8gR2V0IHRoZSB1c2VyJ3MgZXhpc3RpbmcgcGF5bWVudCBtZXRob2RzXG4gIGNvbnN0IG1ldGhvZHMgPSBnZXRVc2VyUGF5bWVudE1ldGhvZHModXNlcklkKTtcbiAgXG4gIC8vIEZpbmQgdGhlIG1ldGhvZCB0byB1cGRhdGVcbiAgY29uc3QgbWV0aG9kSW5kZXggPSBtZXRob2RzLmZpbmRJbmRleChtZXRob2QgPT4gbWV0aG9kLmlkID09PSBtZXRob2RJZCk7XG4gIFxuICBpZiAobWV0aG9kSW5kZXggPT09IC0xKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgXG4gIC8vIENyZWF0ZSB0aGUgdXBkYXRlZCBtZXRob2RcbiAgY29uc3QgdXBkYXRlZE1ldGhvZDogUGF5bWVudE1ldGhvZCA9IHtcbiAgICAuLi5tZXRob2RzW21ldGhvZEluZGV4XSxcbiAgICAuLi51cGRhdGVzXG4gIH07XG4gIFxuICAvLyBJZiBzZXR0aW5nIGFzIGRlZmF1bHQsIHVwZGF0ZSBhbGwgb3RoZXIgbWV0aG9kc1xuICBpZiAodXBkYXRlcy5pc0RlZmF1bHQpIHtcbiAgICAvLyBTZXQgYWxsIG1ldGhvZHMgdG8gbm9uLWRlZmF1bHRcbiAgICBtZXRob2RzLmZvckVhY2gobWV0aG9kID0+IHtcbiAgICAgIG1ldGhvZC5pc0RlZmF1bHQgPSBmYWxzZTtcbiAgICB9KTtcbiAgfVxuICBcbiAgLy8gVXBkYXRlIHRoZSBtZXRob2RcbiAgbWV0aG9kc1ttZXRob2RJbmRleF0gPSB1cGRhdGVkTWV0aG9kO1xuICBcbiAgLy8gVXBkYXRlIHRoZSB1c2VyJ3MgcGF5bWVudCBtZXRob2RzXG4gIHVzZXJQYXltZW50TWV0aG9kc1t1c2VySWRdID0gbWV0aG9kcztcbiAgXG4gIHJldHVybiB1cGRhdGVkTWV0aG9kO1xufVxuXG4vKipcbiAqIERlbGV0ZSBhIHBheW1lbnQgbWV0aG9kXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWxldGVQYXltZW50TWV0aG9kKHVzZXJJZDogc3RyaW5nLCBtZXRob2RJZDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIC8vIEdldCB0aGUgdXNlcidzIGV4aXN0aW5nIHBheW1lbnQgbWV0aG9kc1xuICBjb25zdCBtZXRob2RzID0gZ2V0VXNlclBheW1lbnRNZXRob2RzKHVzZXJJZCk7XG4gIFxuICAvLyBGaW5kIHRoZSBtZXRob2QgdG8gZGVsZXRlXG4gIGNvbnN0IG1ldGhvZEluZGV4ID0gbWV0aG9kcy5maW5kSW5kZXgobWV0aG9kID0+IG1ldGhvZC5pZCA9PT0gbWV0aG9kSWQpO1xuICBcbiAgaWYgKG1ldGhvZEluZGV4ID09PSAtMSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBcbiAgLy8gQ2hlY2sgaWYgaXQncyB0aGUgZGVmYXVsdCBtZXRob2RcbiAgY29uc3QgaXNEZWZhdWx0ID0gbWV0aG9kc1ttZXRob2RJbmRleF0uaXNEZWZhdWx0O1xuICBcbiAgLy8gUmVtb3ZlIHRoZSBtZXRob2RcbiAgbWV0aG9kcy5zcGxpY2UobWV0aG9kSW5kZXgsIDEpO1xuICBcbiAgLy8gSWYgd2UgcmVtb3ZlZCB0aGUgZGVmYXVsdCBtZXRob2QgYW5kIHRoZXJlIGFyZSBzdGlsbCBtZXRob2RzIGxlZnQsIHNldCBhIG5ldyBkZWZhdWx0XG4gIGlmIChpc0RlZmF1bHQgJiYgbWV0aG9kcy5sZW5ndGggPiAwKSB7XG4gICAgbWV0aG9kc1swXS5pc0RlZmF1bHQgPSB0cnVlO1xuICB9XG4gIFxuICAvLyBVcGRhdGUgdGhlIHVzZXIncyBwYXltZW50IG1ldGhvZHNcbiAgdXNlclBheW1lbnRNZXRob2RzW3VzZXJJZF0gPSBtZXRob2RzO1xuICBcbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogU2V0IGEgcGF5bWVudCBtZXRob2QgYXMgdGhlIGRlZmF1bHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldERlZmF1bHRQYXltZW50TWV0aG9kKHVzZXJJZDogc3RyaW5nLCBtZXRob2RJZDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIC8vIEdldCB0aGUgdXNlcidzIGV4aXN0aW5nIHBheW1lbnQgbWV0aG9kc1xuICBjb25zdCBtZXRob2RzID0gZ2V0VXNlclBheW1lbnRNZXRob2RzKHVzZXJJZCk7XG4gIFxuICAvLyBGaW5kIHRoZSBtZXRob2QgdG8gc2V0IGFzIGRlZmF1bHRcbiAgY29uc3QgbWV0aG9kSW5kZXggPSBtZXRob2RzLmZpbmRJbmRleChtZXRob2QgPT4gbWV0aG9kLmlkID09PSBtZXRob2RJZCk7XG4gIFxuICBpZiAobWV0aG9kSW5kZXggPT09IC0xKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIFxuICAvLyBTZXQgYWxsIG1ldGhvZHMgdG8gbm9uLWRlZmF1bHRcbiAgbWV0aG9kcy5mb3JFYWNoKG1ldGhvZCA9PiB7XG4gICAgbWV0aG9kLmlzRGVmYXVsdCA9IGZhbHNlO1xuICB9KTtcbiAgXG4gIC8vIFNldCB0aGUgc3BlY2lmaWVkIG1ldGhvZCBhcyBkZWZhdWx0XG4gIG1ldGhvZHNbbWV0aG9kSW5kZXhdLmlzRGVmYXVsdCA9IHRydWU7XG4gIFxuICAvLyBVcGRhdGUgdGhlIHVzZXIncyBwYXltZW50IG1ldGhvZHNcbiAgdXNlclBheW1lbnRNZXRob2RzW3VzZXJJZF0gPSBtZXRob2RzO1xuICBcbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogR2V0IHRoZSBkZWZhdWx0IHBheW1lbnQgbWV0aG9kIGZvciBhIHVzZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERlZmF1bHRQYXltZW50TWV0aG9kKHVzZXJJZDogc3RyaW5nKTogUGF5bWVudE1ldGhvZCB8IG51bGwge1xuICAvLyBHZXQgdGhlIHVzZXIncyBleGlzdGluZyBwYXltZW50IG1ldGhvZHNcbiAgY29uc3QgbWV0aG9kcyA9IGdldFVzZXJQYXltZW50TWV0aG9kcyh1c2VySWQpO1xuICBcbiAgLy8gRmluZCB0aGUgZGVmYXVsdCBtZXRob2RcbiAgY29uc3QgZGVmYXVsdE1ldGhvZCA9IG1ldGhvZHMuZmluZChtZXRob2QgPT4gbWV0aG9kLmlzRGVmYXVsdCk7XG4gIFxuICByZXR1cm4gZGVmYXVsdE1ldGhvZCB8fCBudWxsO1xufVxuXG4vKipcbiAqIE1vY2sgZnVuY3Rpb24gdG8gdmFsaWRhdGUgY2FyZCBkZXRhaWxzXG4gKiBJbiBhIHJlYWwgYXBwLCB0aGlzIHdvdWxkIGJlIGhhbmRsZWQgYnkgdGhlIHBheW1lbnQgcHJvY2Vzc29yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUNhcmREZXRhaWxzKGRldGFpbHM6IFBheW1lbnREZXRhaWxzKTogeyB2YWxpZDogYm9vbGVhbjsgZXJyb3I/OiBzdHJpbmcgfSB7XG4gIC8vIEJhc2ljIHZhbGlkYXRpb25cbiAgaWYgKCFkZXRhaWxzLmNhcmROdW1iZXIucmVwbGFjZSgvXFxzL2csICcnKS5tYXRjaCgvXlxcZHsxNn0kLykpIHtcbiAgICByZXR1cm4geyB2YWxpZDogZmFsc2UsIGVycm9yOiAnSW52YWxpZCBjYXJkIG51bWJlcicgfTtcbiAgfVxuICBcbiAgaWYgKCFkZXRhaWxzLmNhcmROYW1lLnRyaW0oKSkge1xuICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgZXJyb3I6ICdDYXJkaG9sZGVyIG5hbWUgaXMgcmVxdWlyZWQnIH07XG4gIH1cbiAgXG4gIGlmICghZGV0YWlscy5leHBpcnlNb250aCB8fCAhZGV0YWlscy5leHBpcnlZZWFyKSB7XG4gICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBlcnJvcjogJ0V4cGlyeSBkYXRlIGlzIHJlcXVpcmVkJyB9O1xuICB9XG4gIFxuICBpZiAoIWRldGFpbHMuY3Z2Lm1hdGNoKC9eXFxkezN9JC8pKSB7XG4gICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBlcnJvcjogJ0ludmFsaWQgQ1ZWJyB9O1xuICB9XG4gIFxuICAvLyBDaGVjayBpZiBjYXJkIGlzIGV4cGlyZWRcbiAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgY29uc3QgZXhwaXJ5RGF0ZSA9IG5ldyBEYXRlKFxuICAgIHBhcnNlSW50KGAyMCR7ZGV0YWlscy5leHBpcnlZZWFyfWApLCBcbiAgICBwYXJzZUludChkZXRhaWxzLmV4cGlyeU1vbnRoKSAtIDEsIFxuICAgIDFcbiAgKTtcbiAgXG4gIGlmIChleHBpcnlEYXRlIDwgbm93KSB7XG4gICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBlcnJvcjogJ0NhcmQgaGFzIGV4cGlyZWQnIH07XG4gIH1cbiAgXG4gIHJldHVybiB7IHZhbGlkOiB0cnVlIH07XG59XG4iXSwibmFtZXMiOlsiZ2V0VXNlclNlc3Npb24iLCJzdG9yZVVzZXJTZXNzaW9uIiwicHJvY2Vzc1BheW1lbnQiLCJwbGFuVHlwZSIsImJpbGxpbmdDeWNsZSIsImFtb3VudCIsInBheW1lbnREZXRhaWxzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwidHJhbnNhY3Rpb25JZCIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsInN1YnN0cmluZyIsInVzZXIiLCJzdWNjZXNzIiwiZXJyb3IiLCJzdGFydERhdGUiLCJEYXRlIiwiZW5kRGF0ZSIsInNldE1vbnRoIiwiZ2V0TW9udGgiLCJzZXRGdWxsWWVhciIsImdldEZ1bGxZZWFyIiwic3Vic2NyaXB0aW9uIiwibmFtZSIsInByaWNlIiwidG9JU09TdHJpbmciLCJ1cGRhdGVkVXNlciIsInBsYW4iLCJpc0FjdGl2ZSIsInRyaWFsU3RhdHVzIiwidW5kZWZpbmVkIiwiY29uc29sZSIsImhhc0FjdGl2ZVN1YnNjcmlwdGlvbiIsImdldFVzZXJQbGFuTmFtZSIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwic2xpY2UiLCJ1c2VyUGF5bWVudE1ldGhvZHMiLCJnZXRVc2VyUGF5bWVudE1ldGhvZHMiLCJ1c2VySWQiLCJhZGRQYXltZW50TWV0aG9kIiwicGF5bWVudE1ldGhvZCIsImlkIiwic3Vic3RyIiwibmV3TWV0aG9kIiwibWV0aG9kcyIsImxlbmd0aCIsImlzRGVmYXVsdCIsInVwZGF0ZWRNZXRob2RzIiwibWFwIiwibWV0aG9kIiwidXBkYXRlUGF5bWVudE1ldGhvZCIsIm1ldGhvZElkIiwidXBkYXRlcyIsIm1ldGhvZEluZGV4IiwiZmluZEluZGV4IiwidXBkYXRlZE1ldGhvZCIsImZvckVhY2giLCJkZWxldGVQYXltZW50TWV0aG9kIiwic3BsaWNlIiwic2V0RGVmYXVsdFBheW1lbnRNZXRob2QiLCJnZXREZWZhdWx0UGF5bWVudE1ldGhvZCIsImRlZmF1bHRNZXRob2QiLCJmaW5kIiwidmFsaWRhdGVDYXJkRGV0YWlscyIsImRldGFpbHMiLCJjYXJkTnVtYmVyIiwicmVwbGFjZSIsIm1hdGNoIiwidmFsaWQiLCJjYXJkTmFtZSIsInRyaW0iLCJleHBpcnlNb250aCIsImV4cGlyeVllYXIiLCJjdnYiLCJub3ciLCJleHBpcnlEYXRlIiwicGFyc2VJbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/payment-service.ts\n"));

/***/ })

});